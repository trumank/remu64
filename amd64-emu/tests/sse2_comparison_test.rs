use amd64_emu::{Engine, EngineMode, Permission, Register};

#[test]
fn test_pcmpeqb() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PCMPEQB - Compare packed bytes for equality
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PCMPEQB xmm0, xmm1
        0x66, 0x0F, 0x74, 0xC1, // pcmpeqb xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, // Data at offset 0x1020: XMM0 initial value
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0xFF, 0xFE, 0x00, 0x01, 0x7F, 0x80, 0x81,
        0x82, // Data at offset 0x1030: XMM1 value
        0x01, 0x02, 0x04, 0x04, 0x05, 0x07, 0x07, 0x09, 0xFF, 0xFE, 0x00, 0x01, 0x7F, 0x80, 0x81,
        0x83, // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Expected: 0xFF for equal bytes, 0x00 for unequal
    assert_eq!(result[0], 0xFF); // 0x01 == 0x01
    assert_eq!(result[1], 0xFF); // 0x02 == 0x02
    assert_eq!(result[2], 0x00); // 0x03 != 0x04
    assert_eq!(result[3], 0xFF); // 0x04 == 0x04
    assert_eq!(result[4], 0xFF); // 0x05 == 0x05
    assert_eq!(result[5], 0x00); // 0x06 != 0x07
    assert_eq!(result[6], 0xFF); // 0x07 == 0x07
    assert_eq!(result[7], 0x00); // 0x08 != 0x09
    assert_eq!(result[8], 0xFF); // 0xFF == 0xFF
    assert_eq!(result[9], 0xFF); // 0xFE == 0xFE
    assert_eq!(result[10], 0xFF); // 0x00 == 0x00
    assert_eq!(result[11], 0xFF); // 0x01 == 0x01
    assert_eq!(result[12], 0xFF); // 0x7F == 0x7F
    assert_eq!(result[13], 0xFF); // 0x80 == 0x80
    assert_eq!(result[14], 0xFF); // 0x81 == 0x81
    assert_eq!(result[15], 0x00); // 0x82 != 0x83
}

#[test]
fn test_pcmpeqw() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PCMPEQW - Compare packed words for equality
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PCMPEQW xmm0, xmm1
        0x66, 0x0F, 0x75, 0xC1, // pcmpeqw xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, // Data at offset 0x1020: XMM0 initial value (8 words)
        0x01, 0x00, // 0x0001
        0x02, 0x00, // 0x0002
        0xFF, 0xFF, // 0xFFFF
        0x00, 0x80, // 0x8000
        0x34, 0x12, // 0x1234
        0x56, 0x78, // 0x7856
        0x00, 0x00, // 0x0000
        0xAB, 0xCD, // 0xCDAB
        // Data at offset 0x1030: XMM1 value (8 words)
        0x01, 0x00, // 0x0001 (equal)
        0x03, 0x00, // 0x0003 (not equal)
        0xFF, 0xFF, // 0xFFFF (equal)
        0x00, 0x80, // 0x8000 (equal)
        0x34, 0x12, // 0x1234 (equal)
        0x57, 0x78, // 0x7857 (not equal)
        0x00, 0x00, // 0x0000 (equal)
        0xAB, 0xCD, // 0xCDAB (equal)
        // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Check each 16-bit word
    assert_eq!(&result[0..2], &[0xFF, 0xFF]); // Equal
    assert_eq!(&result[2..4], &[0x00, 0x00]); // Not equal
    assert_eq!(&result[4..6], &[0xFF, 0xFF]); // Equal
    assert_eq!(&result[6..8], &[0xFF, 0xFF]); // Equal
    assert_eq!(&result[8..10], &[0xFF, 0xFF]); // Equal
    assert_eq!(&result[10..12], &[0x00, 0x00]); // Not equal
    assert_eq!(&result[12..14], &[0xFF, 0xFF]); // Equal
    assert_eq!(&result[14..16], &[0xFF, 0xFF]); // Equal
}

#[test]
fn test_pcmpeqd() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PCMPEQD - Compare packed doublewords for equality
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PCMPEQD xmm0, xmm1
        0x66, 0x0F, 0x76, 0xC1, // pcmpeqd xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, // Data at offset 0x1020: XMM0 initial value (4 dwords)
        0x01, 0x00, 0x00, 0x00, // 0x00000001
        0xFF, 0xFF, 0xFF, 0xFF, // 0xFFFFFFFF
        0x78, 0x56, 0x34, 0x12, // 0x12345678
        0x00, 0x00, 0x00, 0x80, // 0x80000000
        // Data at offset 0x1030: XMM1 value (4 dwords)
        0x01, 0x00, 0x00, 0x00, // 0x00000001 (equal)
        0xFF, 0xFF, 0xFF, 0xFF, // 0xFFFFFFFF (equal)
        0x79, 0x56, 0x34, 0x12, // 0x12345679 (not equal)
        0x00, 0x00, 0x00, 0x80, // 0x80000000 (equal)
        // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Check each 32-bit doubleword
    assert_eq!(&result[0..4], &[0xFF, 0xFF, 0xFF, 0xFF]); // Equal
    assert_eq!(&result[4..8], &[0xFF, 0xFF, 0xFF, 0xFF]); // Equal
    assert_eq!(&result[8..12], &[0x00, 0x00, 0x00, 0x00]); // Not equal
    assert_eq!(&result[12..16], &[0xFF, 0xFF, 0xFF, 0xFF]); // Equal
}

#[test]
fn test_pcmpgtb() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PCMPGTB - Compare packed signed bytes for greater than
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PCMPGTB xmm0, xmm1
        0x66, 0x0F, 0x64, 0xC1, // pcmpgtb xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90,
        // Data at offset 0x1020: XMM0 initial value (signed bytes)
        0x01, 0x02, 0x00, 0xFF, // 1, 2, 0, -1
        0x7F, 0x80, 0x81, 0xFE, // 127, -128, -127, -2
        0x10, 0x20, 0x30, 0x40, // 16, 32, 48, 64
        0x50, 0x60, 0x70, 0x7E, // 80, 96, 112, 126
        // Data at offset 0x1030: XMM1 value (signed bytes)
        0x00, 0x02, 0x01, 0xFE, // 0, 2, 1, -2
        0x7E, 0x81, 0x80, 0xFF, // 126, -127, -128, -1
        0x0F, 0x1F, 0x2F, 0x41, // 15, 31, 47, 65
        0x51, 0x5F, 0x6F, 0x7F, // 81, 95, 111, 127
        // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Expected results based on signed comparison
    assert_eq!(result[0], 0xFF); // 1 > 0
    assert_eq!(result[1], 0x00); // 2 == 2
    assert_eq!(result[2], 0x00); // 0 < 1
    assert_eq!(result[3], 0xFF); // -1 > -2
    assert_eq!(result[4], 0xFF); // 127 > 126
    assert_eq!(result[5], 0x00); // -128 < -127
    assert_eq!(result[6], 0xFF); // -127 > -128
    assert_eq!(result[7], 0x00); // -2 < -1
    assert_eq!(result[8], 0xFF); // 16 > 15
    assert_eq!(result[9], 0xFF); // 32 > 31
    assert_eq!(result[10], 0xFF); // 48 > 47
    assert_eq!(result[11], 0x00); // 64 < 65
    assert_eq!(result[12], 0x00); // 80 < 81
    assert_eq!(result[13], 0xFF); // 96 > 95
    assert_eq!(result[14], 0xFF); // 112 > 111
    assert_eq!(result[15], 0x00); // 126 < 127
}

#[test]
fn test_pcmpgtw() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PCMPGTW - Compare packed signed words for greater than
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PCMPGTW xmm0, xmm1
        0x66, 0x0F, 0x65, 0xC1, // pcmpgtw xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90,
        // Data at offset 0x1020: XMM0 initial value (8 signed words)
        0x01, 0x00, // 1
        0xFF, 0xFF, // -1
        0xFF, 0x7F, // 32767
        0x00, 0x80, // -32768
        0x00, 0x10, // 4096
        0x00, 0xF0, // -4096
        0x34, 0x12, // 4660
        0xCC, 0xED, // -4660
        // Data at offset 0x1030: XMM1 value (8 signed words)
        0x00, 0x00, // 0
        0xFE, 0xFF, // -2
        0xFE, 0x7F, // 32766
        0x01, 0x80, // -32767
        0xFF, 0x0F, // 4095
        0x01, 0xF0, // -4095
        0x34, 0x12, // 4660 (equal)
        0xCD, 0xED, // -4659
        // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Check each 16-bit word
    assert_eq!(&result[0..2], &[0xFF, 0xFF]); // 1 > 0
    assert_eq!(&result[2..4], &[0xFF, 0xFF]); // -1 > -2
    assert_eq!(&result[4..6], &[0xFF, 0xFF]); // 32767 > 32766
    assert_eq!(&result[6..8], &[0x00, 0x00]); // -32768 < -32767
    assert_eq!(&result[8..10], &[0xFF, 0xFF]); // 4096 > 4095
    assert_eq!(&result[10..12], &[0x00, 0x00]); // -4096 < -4095
    assert_eq!(&result[12..14], &[0x00, 0x00]); // 4660 == 4660
    assert_eq!(&result[14..16], &[0x00, 0x00]); // -4660 < -4659
}

#[test]
fn test_pcmpgtd() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PCMPGTD - Compare packed signed doublewords for greater than
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PCMPGTD xmm0, xmm1
        0x66, 0x0F, 0x66, 0xC1, // pcmpgtd xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90,
        // Data at offset 0x1020: XMM0 initial value (4 signed dwords)
        0x01, 0x00, 0x00, 0x00, // 1
        0xFF, 0xFF, 0xFF, 0xFF, // -1
        0xFF, 0xFF, 0xFF, 0x7F, // 2147483647 (INT_MAX)
        0x00, 0x00, 0x00, 0x80, // -2147483648 (INT_MIN)
        // Data at offset 0x1030: XMM1 value (4 signed dwords)
        0x00, 0x00, 0x00, 0x00, // 0
        0xFE, 0xFF, 0xFF, 0xFF, // -2
        0xFE, 0xFF, 0xFF, 0x7F, // 2147483646
        0x01, 0x00, 0x00, 0x80, // -2147483647
        // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Check each 32-bit doubleword
    assert_eq!(&result[0..4], &[0xFF, 0xFF, 0xFF, 0xFF]); // 1 > 0
    assert_eq!(&result[4..8], &[0xFF, 0xFF, 0xFF, 0xFF]); // -1 > -2
    assert_eq!(&result[8..12], &[0xFF, 0xFF, 0xFF, 0xFF]); // INT_MAX > INT_MAX-1
    assert_eq!(&result[12..16], &[0x00, 0x00, 0x00, 0x00]); // INT_MIN < INT_MIN+1
}
