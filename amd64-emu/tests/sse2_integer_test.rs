use amd64_emu::{Engine, EngineMode, Permission, Register};

#[test]
fn test_paddb() {
    let mut engine = Engine::new(EngineMode::Mode64);
    
    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();
    
    // Test PADDB - Add packed bytes
    let code = vec![
        // Initialize XMM0 with test values
        0x66, 0x0F, 0x6F, 0x05, 0x20, 0x00, 0x00, 0x00,  // movdqa xmm0, [rip + 0x20]
        // Initialize XMM1 with test values
        0x66, 0x0F, 0x6F, 0x0D, 0x28, 0x00, 0x00, 0x00,  // movdqa xmm1, [rip + 0x28]
        // PADDB xmm0, xmm1
        0x66, 0x0F, 0xFC, 0xC1,  // paddb xmm0, xmm1
        // Move result to memory for checking
        0x66, 0x0F, 0x7F, 0x05, 0x30, 0x00, 0x00, 0x00,  // movdqa [rip + 0x30], xmm0
        // Halt
        0xF4,
        
        // Padding
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 
        
        // Data at offset 0x20: XMM0 initial value
        0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80,
        0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0xFF,
        
        // Data at offset 0x30: XMM1 value
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x01,
        
        // Space for result at offset 0x40
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    
    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);
    
    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + code.len() as u64, 0, 0).is_ok());
    
    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();
    
    // Expected: Each byte is the sum of corresponding bytes
    assert_eq!(result[0], 0x11);  // 0x10 + 0x01
    assert_eq!(result[1], 0x22);  // 0x20 + 0x02
    assert_eq!(result[2], 0x33);  // 0x30 + 0x03
    assert_eq!(result[3], 0x44);  // 0x40 + 0x04
    assert_eq!(result[4], 0x55);  // 0x50 + 0x05
    assert_eq!(result[5], 0x66);  // 0x60 + 0x06
    assert_eq!(result[6], 0x77);  // 0x70 + 0x07
    assert_eq!(result[7], 0x88);  // 0x80 + 0x08 (wraps around)
    assert_eq!(result[8], 0x99);  // 0x90 + 0x09
    assert_eq!(result[9], 0xAA);  // 0xA0 + 0x0A
    assert_eq!(result[10], 0xBB); // 0xB0 + 0x0B
    assert_eq!(result[11], 0xCC); // 0xC0 + 0x0C
    assert_eq!(result[12], 0xDD); // 0xD0 + 0x0D
    assert_eq!(result[13], 0xEE); // 0xE0 + 0x0E
    assert_eq!(result[14], 0xFF); // 0xF0 + 0x0F
    assert_eq!(result[15], 0x00); // 0xFF + 0x01 (wraps to 0x00)
}

#[test]
fn test_paddw() {
    let mut engine = Engine::new(EngineMode::Mode64);
    
    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();
    
    // Test PADDW - Add packed words (16-bit)
    let code = vec![
        // Initialize XMM0 with test values
        0x66, 0x0F, 0x6F, 0x05, 0x20, 0x00, 0x00, 0x00,  // movdqa xmm0, [rip + 0x20]
        // Initialize XMM1 with test values  
        0x66, 0x0F, 0x6F, 0x0D, 0x28, 0x00, 0x00, 0x00,  // movdqa xmm1, [rip + 0x28]
        // PADDW xmm0, xmm1
        0x66, 0x0F, 0xFD, 0xC1,  // paddw xmm0, xmm1
        // Move result to memory for checking
        0x66, 0x0F, 0x7F, 0x05, 0x30, 0x00, 0x00, 0x00,  // movdqa [rip + 0x30], xmm0
        // Halt
        0xF4,
        
        // Padding
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
        
        // Data at offset 0x20: XMM0 initial value (8 words)
        0x00, 0x10,  // 0x1000
        0x00, 0x20,  // 0x2000  
        0x00, 0x30,  // 0x3000
        0x00, 0x40,  // 0x4000
        0x00, 0x50,  // 0x5000
        0x00, 0x60,  // 0x6000
        0x00, 0x70,  // 0x7000
        0xFF, 0xFF,  // 0xFFFF
        
        // Data at offset 0x30: XMM1 value (8 words)
        0x01, 0x00,  // 0x0001
        0x02, 0x00,  // 0x0002
        0x03, 0x00,  // 0x0003
        0x04, 0x00,  // 0x0004
        0x05, 0x00,  // 0x0005
        0x06, 0x00,  // 0x0006
        0x07, 0x00,  // 0x0007
        0x01, 0x00,  // 0x0001
        
        // Space for result at offset 0x40
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    
    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);
    
    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + code.len() as u64, 0, 0).is_ok());
    
    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();
    
    // Check each 16-bit word
    assert_eq!(&result[0..2], &[0x01, 0x10]);   // 0x1000 + 0x0001 = 0x1001
    assert_eq!(&result[2..4], &[0x02, 0x20]);   // 0x2000 + 0x0002 = 0x2002
    assert_eq!(&result[4..6], &[0x03, 0x30]);   // 0x3000 + 0x0003 = 0x3003
    assert_eq!(&result[6..8], &[0x04, 0x40]);   // 0x4000 + 0x0004 = 0x4004
    assert_eq!(&result[8..10], &[0x05, 0x50]);  // 0x5000 + 0x0005 = 0x5005
    assert_eq!(&result[10..12], &[0x06, 0x60]); // 0x6000 + 0x0006 = 0x6006
    assert_eq!(&result[12..14], &[0x07, 0x70]); // 0x7000 + 0x0007 = 0x7007
    assert_eq!(&result[14..16], &[0x00, 0x00]); // 0xFFFF + 0x0001 = 0x10000 (wraps to 0x0000)
}

#[test]
fn test_paddd() {
    let mut engine = Engine::new(EngineMode::Mode64);
    
    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();
    
    // Test PADDD - Add packed doublewords (32-bit)
    let code = vec![
        // Initialize XMM0 with test values
        0x66, 0x0F, 0x6F, 0x05, 0x20, 0x00, 0x00, 0x00,  // movdqa xmm0, [rip + 0x20]
        // Initialize XMM1 with test values
        0x66, 0x0F, 0x6F, 0x0D, 0x28, 0x00, 0x00, 0x00,  // movdqa xmm1, [rip + 0x28]
        // PADDD xmm0, xmm1
        0x66, 0x0F, 0xFE, 0xC1,  // paddd xmm0, xmm1
        // Move result to memory for checking
        0x66, 0x0F, 0x7F, 0x05, 0x30, 0x00, 0x00, 0x00,  // movdqa [rip + 0x30], xmm0
        // Halt
        0xF4,
        
        // Padding
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
        
        // Data at offset 0x20: XMM0 initial value (4 dwords)
        0x00, 0x00, 0x00, 0x10,  // 0x10000000
        0x00, 0x00, 0x00, 0x20,  // 0x20000000
        0x00, 0x00, 0x00, 0x30,  // 0x30000000
        0xFF, 0xFF, 0xFF, 0xFF,  // 0xFFFFFFFF
        
        // Data at offset 0x30: XMM1 value (4 dwords)
        0x01, 0x00, 0x00, 0x00,  // 0x00000001
        0x02, 0x00, 0x00, 0x00,  // 0x00000002
        0x03, 0x00, 0x00, 0x00,  // 0x00000003
        0x01, 0x00, 0x00, 0x00,  // 0x00000001
        
        // Space for result at offset 0x40
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    
    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);
    
    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + code.len() as u64, 0, 0).is_ok());
    
    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();
    
    // Check each 32-bit dword
    assert_eq!(&result[0..4], &[0x01, 0x00, 0x00, 0x10]);   // 0x10000000 + 0x00000001
    assert_eq!(&result[4..8], &[0x02, 0x00, 0x00, 0x20]);   // 0x20000000 + 0x00000002
    assert_eq!(&result[8..12], &[0x03, 0x00, 0x00, 0x30]);  // 0x30000000 + 0x00000003
    assert_eq!(&result[12..16], &[0x00, 0x00, 0x00, 0x00]); // 0xFFFFFFFF + 0x00000001 (wraps)
}

#[test]
fn test_paddq() {
    let mut engine = Engine::new(EngineMode::Mode64);
    
    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();
    
    // Test PADDQ - Add packed quadwords (64-bit)
    let code = vec![
        // Initialize XMM0 with test values
        0x66, 0x0F, 0x6F, 0x05, 0x20, 0x00, 0x00, 0x00,  // movdqa xmm0, [rip + 0x20]
        // Initialize XMM1 with test values
        0x66, 0x0F, 0x6F, 0x0D, 0x28, 0x00, 0x00, 0x00,  // movdqa xmm1, [rip + 0x28]
        // PADDQ xmm0, xmm1
        0x66, 0x0F, 0xD4, 0xC1,  // paddq xmm0, xmm1
        // Move result to memory for checking
        0x66, 0x0F, 0x7F, 0x05, 0x30, 0x00, 0x00, 0x00,  // movdqa [rip + 0x30], xmm0
        // Halt
        0xF4,
        
        // Padding
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
        
        // Data at offset 0x20: XMM0 initial value (2 qwords)
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,  // 0x1000000000000000
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 0xFFFFFFFFFFFFFFFF
        
        // Data at offset 0x30: XMM1 value (2 qwords)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x0000000000000001
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x0000000000000001
        
        // Space for result at offset 0x40
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    
    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);
    
    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + code.len() as u64, 0, 0).is_ok());
    
    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();
    
    // Check each 64-bit qword
    assert_eq!(&result[0..8], &[0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10]); // 0x1000000000000000 + 1
    assert_eq!(&result[8..16], &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]); // 0xFFFFFFFFFFFFFFFF + 1 (wraps)
}

#[test]
fn test_paddb_memory_operand() {
    let mut engine = Engine::new(EngineMode::Mode64);
    
    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();
    
    // Test PADDB with memory operand
    let code = vec![
        // Initialize XMM0 with test values
        0x66, 0x0F, 0x6F, 0x05, 0x20, 0x00, 0x00, 0x00,  // movdqa xmm0, [rip + 0x20]
        // PADDB xmm0, [rip + 0x28] - add from memory
        0x66, 0x0F, 0xFC, 0x05, 0x28, 0x00, 0x00, 0x00,  // paddb xmm0, [rip + 0x28]
        // Move result to memory for checking
        0x66, 0x0F, 0x7F, 0x05, 0x30, 0x00, 0x00, 0x00,  // movdqa [rip + 0x30], xmm0
        // Halt
        0xF4,
        
        // Padding
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
        
        // Data at offset 0x20: XMM0 initial value
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
        
        // Data at offset 0x30: Memory operand
        0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80,
        0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0xEF,
        
        // Space for result at offset 0x40
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    
    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);
    
    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + code.len() as u64, 0, 0).is_ok());
    
    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();
    
    // Check a few bytes
    assert_eq!(result[0], 0x11);  // 0x01 + 0x10
    assert_eq!(result[1], 0x22);  // 0x02 + 0x20
    assert_eq!(result[7], 0x88);  // 0x08 + 0x80
    assert_eq!(result[15], 0xFF); // 0x10 + 0xEF
}