use amd64_emu::{Engine, EngineMode, Permission, Register};

#[test]
fn test_paddb() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PADDB - Add packed bytes
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PADDB xmm0, xmm1
        0x66, 0x0F, 0xFC, 0xC1, // paddb xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, // Data at offset 0x1020: XMM0 initial value
        0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,
        0xFF, // Data at offset 0x1030: XMM1 value
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x01, // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions (stop after the 4 instructions)
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Expected: Each byte is the sum of corresponding bytes
    assert_eq!(result[0], 0x11); // 0x10 + 0x01
    assert_eq!(result[1], 0x22); // 0x20 + 0x02
    assert_eq!(result[2], 0x33); // 0x30 + 0x03
    assert_eq!(result[3], 0x44); // 0x40 + 0x04
    assert_eq!(result[4], 0x55); // 0x50 + 0x05
    assert_eq!(result[5], 0x66); // 0x60 + 0x06
    assert_eq!(result[6], 0x77); // 0x70 + 0x07
    assert_eq!(result[7], 0x88); // 0x80 + 0x08 (wraps around)
    assert_eq!(result[8], 0x99); // 0x90 + 0x09
    assert_eq!(result[9], 0xAA); // 0xA0 + 0x0A
    assert_eq!(result[10], 0xBB); // 0xB0 + 0x0B
    assert_eq!(result[11], 0xCC); // 0xC0 + 0x0C
    assert_eq!(result[12], 0xDD); // 0xD0 + 0x0D
    assert_eq!(result[13], 0xEE); // 0xE0 + 0x0E
    assert_eq!(result[14], 0xFF); // 0xF0 + 0x0F
    assert_eq!(result[15], 0x00); // 0xFF + 0x01 (wraps to 0x00)
}

#[test]
fn test_paddw() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PADDW - Add packed words (16-bit)
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PADDW xmm0, xmm1
        0x66, 0x0F, 0xFD, 0xC1, // paddw xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, // Data at offset 0x1020: XMM0 initial value (8 words)
        0x00, 0x10, // 0x1000
        0x00, 0x20, // 0x2000
        0x00, 0x30, // 0x3000
        0x00, 0x40, // 0x4000
        0x00, 0x50, // 0x5000
        0x00, 0x60, // 0x6000
        0x00, 0x70, // 0x7000
        0xFF, 0xFF, // 0xFFFF
        // Data at offset 0x1030: XMM1 value (8 words)
        0x01, 0x00, // 0x0001
        0x02, 0x00, // 0x0002
        0x03, 0x00, // 0x0003
        0x04, 0x00, // 0x0004
        0x05, 0x00, // 0x0005
        0x06, 0x00, // 0x0006
        0x07, 0x00, // 0x0007
        0x01, 0x00, // 0x0001
        // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions (stop after the 4 instructions)
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Check each 16-bit word
    assert_eq!(&result[0..2], &[0x01, 0x10]); // 0x1000 + 0x0001 = 0x1001
    assert_eq!(&result[2..4], &[0x02, 0x20]); // 0x2000 + 0x0002 = 0x2002
    assert_eq!(&result[4..6], &[0x03, 0x30]); // 0x3000 + 0x0003 = 0x3003
    assert_eq!(&result[6..8], &[0x04, 0x40]); // 0x4000 + 0x0004 = 0x4004
    assert_eq!(&result[8..10], &[0x05, 0x50]); // 0x5000 + 0x0005 = 0x5005
    assert_eq!(&result[10..12], &[0x06, 0x60]); // 0x6000 + 0x0006 = 0x6006
    assert_eq!(&result[12..14], &[0x07, 0x70]); // 0x7000 + 0x0007 = 0x7007
    assert_eq!(&result[14..16], &[0x00, 0x00]); // 0xFFFF + 0x0001 = 0x10000 (wraps to 0x0000)
}

#[test]
fn test_paddd() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PADDD - Add packed doublewords (32-bit)
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PADDD xmm0, xmm1
        0x66, 0x0F, 0xFE, 0xC1, // paddd xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, // Data at offset 0x1020: XMM0 initial value (4 dwords)
        0x00, 0x00, 0x00, 0x10, // 0x10000000
        0x00, 0x00, 0x00, 0x20, // 0x20000000
        0x00, 0x00, 0x00, 0x30, // 0x30000000
        0xFF, 0xFF, 0xFF, 0xFF, // 0xFFFFFFFF
        // Data at offset 0x1030: XMM1 value (4 dwords)
        0x01, 0x00, 0x00, 0x00, // 0x00000001
        0x02, 0x00, 0x00, 0x00, // 0x00000002
        0x03, 0x00, 0x00, 0x00, // 0x00000003
        0x01, 0x00, 0x00, 0x00, // 0x00000001
        // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions (stop after the 4 instructions)
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Check each 32-bit dword
    assert_eq!(&result[0..4], &[0x01, 0x00, 0x00, 0x10]); // 0x10000000 + 0x00000001
    assert_eq!(&result[4..8], &[0x02, 0x00, 0x00, 0x20]); // 0x20000000 + 0x00000002
    assert_eq!(&result[8..12], &[0x03, 0x00, 0x00, 0x30]); // 0x30000000 + 0x00000003
    assert_eq!(&result[12..16], &[0x00, 0x00, 0x00, 0x00]); // 0xFFFFFFFF + 0x00000001 (wraps)
}

#[test]
fn test_paddq() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PADDQ - Add packed quadwords (64-bit)
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PADDQ xmm0, xmm1
        0x66, 0x0F, 0xD4, 0xC1, // paddq xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, // Data at offset 0x1020: XMM0 initial value (2 qwords)
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // 0x1000000000000000
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0xFFFFFFFFFFFFFFFF
        // Data at offset 0x1030: XMM1 value (2 qwords)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0000000000000001
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0000000000000001
        // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions (stop after the 4 instructions)
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Check each 64-bit qword
    assert_eq!(
        &result[0..8],
        &[0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10]
    ); // 0x1000000000000000 + 1
    assert_eq!(
        &result[8..16],
        &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
    ); // 0xFFFFFFFFFFFFFFFF + 1 (wraps)
}

#[test]
fn test_paddb_memory_operand() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PADDB with memory operand
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x10 = 0x1018)
        0x66, 0x0F, 0x6F, 0x05, 0x10, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x10]
        // PADDB xmm0, [rip + 0x18] - add from memory (at 0x1008, next RIP is 0x1010, +0x18 = 0x1028)
        0x66, 0x0F, 0xFC, 0x05, 0x18, 0x00, 0x00, 0x00, // paddb xmm0, [rip + 0x18]
        // Move result to memory for checking (at 0x1010, next RIP is 0x1018, +0x20 = 0x1038)
        0x66, 0x0F, 0x7F, 0x05, 0x20, 0x00, 0x00, 0x00, // movdqa [rip + 0x20], xmm0
        // Data at offset 0x1018: XMM0 initial value
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x10, // Data at offset 0x1028: Memory operand
        0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,
        0xEF, // Space for result at offset 0x1038
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions (stop after the 3 instructions)
    assert!(engine.emu_start(0x1000, 0x1000 + 0x18, 0, 0).is_ok());

    // Check result (written at offset 0x1038)
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1038, &mut result).unwrap();

    // Check a few bytes
    assert_eq!(result[0], 0x11); // 0x01 + 0x10
    assert_eq!(result[1], 0x22); // 0x02 + 0x20
    assert_eq!(result[7], 0x88); // 0x08 + 0x80
    assert_eq!(result[15], 0xFF); // 0x10 + 0xEF
}

#[test]
fn test_psubb() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PSUBB - Subtract packed bytes
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PSUBB xmm0, xmm1
        0x66, 0x0F, 0xF8, 0xC1, // psubb xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, // Data at offset 0x1020: XMM0 initial value
        0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0x00,
        0xFF, // Data at offset 0x1030: XMM1 value (values to subtract)
        0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x01,
        0x01, // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions (stop after the 4 instructions)
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Expected: Each byte is the difference
    assert_eq!(result[0], 0x10); // 0x20 - 0x10
    assert_eq!(result[1], 0x20); // 0x30 - 0x10
    assert_eq!(result[2], 0x30); // 0x40 - 0x10
    assert_eq!(result[6], 0x70); // 0x80 - 0x10
    assert_eq!(result[14], 0xFF); // 0x00 - 0x01 (wraps to 0xFF)
    assert_eq!(result[15], 0xFE); // 0xFF - 0x01
}

#[test]
fn test_psubw() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PSUBW - Subtract packed words (16-bit)
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PSUBW xmm0, xmm1
        0x66, 0x0F, 0xF9, 0xC1, // psubw xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, // Data at offset 0x1020: XMM0 initial value (8 words)
        0x00, 0x20, // 0x2000
        0x00, 0x30, // 0x3000
        0x00, 0x40, // 0x4000
        0x00, 0x50, // 0x5000
        0x00, 0x60, // 0x6000
        0x00, 0x70, // 0x7000
        0x00, 0x80, // 0x8000
        0x00, 0x00, // 0x0000
        // Data at offset 0x1030: XMM1 value (8 words)
        0x00, 0x10, // 0x1000
        0x00, 0x10, // 0x1000
        0x00, 0x10, // 0x1000
        0x00, 0x10, // 0x1000
        0x00, 0x10, // 0x1000
        0x00, 0x10, // 0x1000
        0x00, 0x10, // 0x1000
        0x01, 0x00, // 0x0001
        // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions (stop after the 4 instructions)
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Check each 16-bit word
    assert_eq!(&result[0..2], &[0x00, 0x10]); // 0x2000 - 0x1000 = 0x1000
    assert_eq!(&result[2..4], &[0x00, 0x20]); // 0x3000 - 0x1000 = 0x2000
    assert_eq!(&result[4..6], &[0x00, 0x30]); // 0x4000 - 0x1000 = 0x3000
    assert_eq!(&result[14..16], &[0xFF, 0xFF]); // 0x0000 - 0x0001 = 0xFFFF (wraps)
}

#[test]
fn test_pand() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PAND - Bitwise AND of packed data
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PAND xmm0, xmm1
        0x66, 0x0F, 0xDB, 0xC1, // pand xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, // Data at offset 0x1020: XMM0 initial value
        0xFF, 0xFF, 0xFF, 0xFF, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, 0x0F, 0x0F, 0x0F,
        0x0F, // Data at offset 0x1030: XMM1 value
        0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xAA, 0xAA, 0xAA, 0xAA, 0xF0, 0xF0, 0xF0,
        0xF0, // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Expected: Bitwise AND of corresponding bytes
    assert_eq!(&result[0..4], &[0x0F, 0x0F, 0x0F, 0x0F]); // 0xFF & 0x0F
    assert_eq!(&result[4..8], &[0xAA, 0xAA, 0xAA, 0xAA]); // 0xAA & 0xFF
    assert_eq!(&result[8..12], &[0x00, 0x00, 0x00, 0x00]); // 0x55 & 0xAA = 0
    assert_eq!(&result[12..16], &[0x00, 0x00, 0x00, 0x00]); // 0x0F & 0xF0 = 0
}

#[test]
fn test_pandn() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PANDN - Bitwise AND NOT of packed data (NOT dst AND src)
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PANDN xmm0, xmm1
        0x66, 0x0F, 0xDF, 0xC1, // pandn xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, // Data at offset 0x1020: XMM0 initial value
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0x0F, 0x0F, 0x0F,
        0x0F, // Data at offset 0x1030: XMM1 value
        0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x55, 0x55, 0x55, 0x55, 0xF0, 0xF0, 0xF0,
        0xF0, // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Expected: (~dst) & src
    assert_eq!(&result[0..4], &[0x00, 0x00, 0x00, 0x00]); // (~0xFF) & 0x0F = 0
    assert_eq!(&result[4..8], &[0xFF, 0xFF, 0xFF, 0xFF]); // (~0x00) & 0xFF = 0xFF
    assert_eq!(&result[8..12], &[0x55, 0x55, 0x55, 0x55]); // (~0xAA) & 0x55 = 0x55
    assert_eq!(&result[12..16], &[0xF0, 0xF0, 0xF0, 0xF0]); // (~0x0F) & 0xF0 = 0xF0
}

#[test]
fn test_por() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test POR - Bitwise OR of packed data
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // POR xmm0, xmm1
        0x66, 0x0F, 0xEB, 0xC1, // por xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, // Data at offset 0x1020: XMM0 initial value
        0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0x0F, 0x0F, 0x0F,
        0x0F, // Data at offset 0x1030: XMM1 value
        0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x55, 0x55, 0x55, 0x55, 0xF0, 0xF0, 0xF0,
        0xF0, // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Expected: Bitwise OR of corresponding bytes
    assert_eq!(&result[0..4], &[0xFF, 0xFF, 0xFF, 0xFF]); // 0xF0 | 0x0F = 0xFF
    assert_eq!(&result[4..8], &[0xFF, 0xFF, 0xFF, 0xFF]); // 0x00 | 0xFF = 0xFF
    assert_eq!(&result[8..12], &[0xFF, 0xFF, 0xFF, 0xFF]); // 0xAA | 0x55 = 0xFF
    assert_eq!(&result[12..16], &[0xFF, 0xFF, 0xFF, 0xFF]); // 0x0F | 0xF0 = 0xFF
}

#[test]
fn test_pxor() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PXOR - Bitwise XOR of packed data
    let code = vec![
        // Initialize XMM0 with test values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // Initialize XMM1 with test values (at 0x1008, next RIP is 0x1010, +0x20 = 0x1030)
        0x66, 0x0F, 0x6F, 0x0D, 0x20, 0x00, 0x00, 0x00, // movdqa xmm1, [rip + 0x20]
        // PXOR xmm0, xmm1
        0x66, 0x0F, 0xEF, 0xC1, // pxor xmm0, xmm1
        // Move result to memory for checking (at 0x1014, next RIP is 0x101C, +0x24 = 0x1040)
        0x66, 0x0F, 0x7F, 0x05, 0x24, 0x00, 0x00, 0x00, // movdqa [rip + 0x24], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, // Data at offset 0x1020: XMM0 initial value
        0xFF, 0xFF, 0xFF, 0xFF, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, 0x12, 0x34, 0x56,
        0x78, // Data at offset 0x1030: XMM1 value
        0xFF, 0xFF, 0xFF, 0xFF, 0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0x12, 0x34, 0x56,
        0x78, // Space for result at offset 0x1040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions
    assert!(engine.emu_start(0x1000, 0x1000 + 0x1C, 0, 0).is_ok());

    // Check result
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1040, &mut result).unwrap();

    // Expected: Bitwise XOR of corresponding bytes
    assert_eq!(&result[0..4], &[0x00, 0x00, 0x00, 0x00]); // 0xFF ^ 0xFF = 0
    assert_eq!(&result[4..8], &[0xFF, 0xFF, 0xFF, 0xFF]); // 0xAA ^ 0x55 = 0xFF
    assert_eq!(&result[8..12], &[0xFF, 0xFF, 0xFF, 0xFF]); // 0x55 ^ 0xAA = 0xFF
    assert_eq!(&result[12..16], &[0x00, 0x00, 0x00, 0x00]); // Same value XOR = 0
}

#[test]
fn test_pxor_self() {
    let mut engine = Engine::new(EngineMode::Mode64);

    // Map memory
    engine.mem_map(0x1000, 0x1000, Permission::ALL).unwrap();

    // Test PXOR with same register (common idiom to zero a register)
    let code = vec![
        // Initialize XMM0 with non-zero values (at 0x1000, next RIP is 0x1008, +0x18 = 0x1020)
        0x66, 0x0F, 0x6F, 0x05, 0x18, 0x00, 0x00, 0x00, // movdqa xmm0, [rip + 0x18]
        // PXOR xmm0, xmm0 (zero the register)
        0x66, 0x0F, 0xEF, 0xC0, // pxor xmm0, xmm0
        // Move result to memory for checking (at 0x100C, next RIP is 0x1014, +0x1C = 0x1030)
        0x66, 0x0F, 0x7F, 0x05, 0x1C, 0x00, 0x00, 0x00, // movdqa [rip + 0x1C], xmm0
        // Padding to reach 0x1020
        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
        // Data at offset 0x1020
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, // Space for result at offset 0x1030
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];

    engine.mem_write(0x1000, &code).unwrap();
    engine.reg_write(Register::RIP, 0x1000);

    // Execute instructions (stop after the 3 instructions)
    assert!(engine.emu_start(0x1000, 0x1000 + 0x14, 0, 0).is_ok());

    // Check result - should be all zeros
    let mut result = vec![0u8; 16];
    engine.mem_read(0x1030, &mut result).unwrap();
    assert_eq!(result, vec![0u8; 16]);
}
